using ACDecompileParser.Lib.Output;
using ACDecompileParser.Shared.Lib.Models;
using ACDecompileParser.Shared.Lib.Constants;
using System.Collections.Generic;
using System.IO;
using Xunit;

namespace ACDecompileParser.Tests.Lib.Output;

public class CSharpFileOutputGeneratorTests : IDisposable
{
    private readonly string _tempDir;
    private readonly CSharpFileOutputGenerator _generator;

    public CSharpFileOutputGeneratorTests()
    {
        _tempDir = Path.Combine(Path.GetTempPath(), "test_cs_output_" + Guid.NewGuid().ToString());
        _generator = new CSharpFileOutputGenerator();
    }

    public void Dispose()
    {
        if (Directory.Exists(_tempDir))
        {
            Directory.Delete(_tempDir, true);
        }
    }

    [Fact]
    public async Task GenerateCSharpFiles_UsesManualHelperContent_WhenMatchFound()
    {
        // Arrange
        string testKey = "TestInternalType";
        string manualContent = """
                               namespace ACBindings.Manual;
                               public class TestInternalType { // Manual implementation }
                               """;

        // Inject manual helper
        ManualHelpers.Helpers[testKey] = manualContent;

        try
        {
            var typeModels = new List<TypeModel>
            {
                new TypeModel
                {
                    BaseName = testKey,
                    Namespace = "ACBindings",
                    Type = TypeType.Class,
                    Source = "class TestInternalType { // Auto-generated }"
                }
            };

            // Act
            await _generator.GenerateCSharpFiles(typeModels, _tempDir);

            // Assert
            string expectedFilePath = Path.Combine(_tempDir, "ACBindings", $"{testKey}.cs");
            Assert.True(File.Exists(expectedFilePath), $"Expected file {expectedFilePath} not found.");

            string actualContent = await File.ReadAllTextAsync(expectedFilePath);
            Assert.Equal(manualContent, actualContent);
        }
        finally
        {
            // Cleanup injected helper
            ManualHelpers.Helpers.Remove(testKey);
        }
    }

    [Fact]
    public async Task GenerateCSharpFiles_UsesAutoGeneratedContent_WhenNoMatchFound()
    {
        // Arrange
        string testKey = "NormalType";
        var typeModels = new List<TypeModel>
        {
            new TypeModel
            {
                BaseName = testKey,
                Namespace = "ACBindings",
                Type = TypeType.Class,
                Source = "class NormalType {}"
            }
        };

        // Act
        await _generator.GenerateCSharpFiles(typeModels, _tempDir);

        // Assert
        string expectedFilePath = Path.Combine(_tempDir, "ACBindings", $"{testKey}.cs");
        Assert.True(File.Exists(expectedFilePath), $"Expected file {expectedFilePath} not found.");

        string actualContent = await File.ReadAllTextAsync(expectedFilePath);
        Assert.DoesNotContain("// Manual implementation", actualContent);
        Assert.Contains(testKey, actualContent); // Just check that the type name is present in the file
    }
}
